# [Algorithm] 我放弃了一 key 到底

- 命题人：unprintable123
- 题目分值：300 分

## 题目描述

<blockquote>
<p>z 导：我原本想整个签名一 key 到底，是不是很大胆？整个签名，一 key 到底。</p>
<p>主持人：基于 <strong>Winternitz</strong> 这个算法。</p>
<p>z 导：就这个算法，就完全是这个算法，一  key 到底。我最早生成公私钥的时候，跟所有随机数生成器说的都是一 key 到底，不管签多少条 message 都只用一个 key。</p>
<p>主持人：难以想象。</p>
<p>z 导：喔，所有随机数生成器 <code>/dev/random</code>、<code>/dev/urandom</code> 它们都很兴奋，<code>token_bytes</code> 它们很兴奋，一 key 到底，一直说的是一 key 到底，我们一直在做一 key 到底的准备，所以当时跟随机数生成器说的时候，我只要你们 992 字节，1KB，他们说为什么，我说很简单，我每天签两遍，一 key 到底签 256 条 message。哇，所有随机数生成器都觉得太厉害了，就一个 key 一直用，一点信息都不能泄露啊。</p>
<p>z 导：但是后来我还是放弃了。你知道为什么？我研究了大量一 key 到底的算法，基于格密码的，同源的，我都看过。其实在 Lamport 的时候，我就想做一个<strong>纯哈希签名</strong>的一 key 到底，后来也没做，你知道最大的问题是什么？当然这是一个专业问题，简单地说最大的问题就是：<strong>重复</strong>。第一是会重复，无论怎么样，我想来想去，因为我算个内行吧，我不签我就知道，key 会被重用。第二个，key 的抗原像攻击性会损失一半以上，安全就不好做了。最后我差不多一个多月的思想斗争，那是个重大决定——一个个随机数生成器都是按照一 key 到底准备的，排熵池呢。</p>
</blockquote>
<p>在放弃一 key 到底后，z 导决定<strong>用 256 个 key</strong> 建一棵树。</p>
<p>“<strong>只要不重复，随便用一个叶子签名都很安全</strong>。”z 导说，“这就是我的，遗憾，但也许是我的一个清醒，或者学习的心得。”</p>
<p><strong>提示：</strong></p>
<ul>
<li>z 导不太熟悉 <strong>Python</strong> 特性，代码实际上并不符合他的设计目标。</li>
<li>建议你花费<strong>几分钟</strong>的时间去学习一下 Winternitz 一次性签名算法，之后再阅读本题代码。</li>
</ul>
<div class="well">
<p><strong>第二阶段提示：</strong></p>
<ul>
<li>重复检查没有考虑索引越界的情况，但 Python 数组使用负数索引并不一定会报错。</li>
<li>key 复用情况下，签名系统就不再安全了。这个攻击是简单的，也是被广泛讨论的。</li>
<li>不同 seed 的难度差距很大，你可能需要用概率做一些复杂度的计算，并进行常见的密码学攻击优化。<del>或者问问GPT</del></li>
</ul>
</div>

**[【附件：下载题目源码（algo-tree.zip）】](attachment/algo-tree.zip)**

**【终端交互：连接到题目】**

## 预期解法

题目实现了一个简单的基于哈希的多次签名（Winternitz + Merkle 树）系统，选手可以选择一个叶子节点来签名消息。本题的漏洞在于代码没有正确防止叶子节点的重复使用，导致攻击者可以使用同一个叶子节点签名两条不同的消息，从而利用 Winternitz 签名的特性伪造签名。

### 重复利用

本题通过 set 来维护已经使用过的叶子节点索引，但没有正确检查索引的范围。注意到 Python 的 -1 是合法索引，因此攻击者可以使用 -1 再次签名不同的消息。

### Winternitz 攻击

本题的第二个难点在于如何只用两条消息伪造签名。

Winternitz 签名的核心思想是将消息哈希值拆分成多个块，通过反复哈希来生成签名。本题算法先将一个哈希值 $H(m)$ 用 $w=21$ 进制表示，得到 $d_1, d_2, \ldots, d_{l_1}$，然后计算校验和 $c=\sum (w - 1 - d_i)$，并将其也用 $w$ 进制表示，得到 $d_{l_1+1}, \ldots, d_{l_1+l_2}$。如果想要伪造签名，我们需要找到两条消息 $m_1$ 和 $m_2$，使得它们对应的 $a_i$ 和 $b_i$ 满足 $\max(a_i, b_i) \geq d_i$.

一个简单的观察是，如果目标 $d_i$ 很小，那么找到两条消息的概率会更大。所以我们可以先估计当前 seed 的难度，选择一个难度较小的 seed 来进行攻击。不妨假设所有 $d_i$ 都是均匀分布的，那么 sample 出一条比它大的消息的概率为 $\prod_i\frac{w - d_i}{w}$。在选好 seed 后，我们可以先枚举第一条消息，然后对还没有被满足的 $d_i$，估计找到第二条消息的概率，从而选出最有希望成功的第一条消息进行尝试。通过这种方法，我们可以在合理的时间内找到两条消息，从而伪造签名，成功获取 flag。

整个攻击流程如下：

1. 选择一个合适的 seed，使其难度小于 70 bit。
2. 枚举第一条消息 $m_1$，并计算其对应的 $d_i$。估计找到第二条消息 $m_2$ 的概率。
3. 选择第二步中概率最高的 $m_1$，继续枚举 $m_2$，直到找到满足条件的 $m_2$。
4. 使用重复利用的叶子节点索引 -1，签名 $m_1$ 和 $m_2$，得到两条合法签名，然后合成伪造签名。
